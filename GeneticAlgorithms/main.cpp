// ГЕНЕТИЧЕСКИЙ АЛГОРИТМ: http://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B0.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D0.B0
// ДОКУМЕНТАЦИЯ ПО C++  : http://ru.cppreference.com/w/

/*
Этапы генетического алгоритма.	*/
/*
================================================================================================
Текущий тип алгоритма -- см. 3.4. Простой генетический алгоритм
ВЫЯСНИТЬ У ПРЕПОДА (записано в вопросник, пока что можно проигнорировать):
	2. ... пропорционально приспособляемости родителей
	3. ... применение операторов инверсии и мутации
------------------------------------------------------------------------------------------------
================================================================================================	*/
/*
1. Задать целевую функцию (приспособленности) для особей популяции
2. Создать начальную популяцию */
/*	Начало цикла	// определить условия его окончания
		( Отбор? )	*/
/*		e1. Размножение (скрещивание) 
			*	см:	Этап 2: определение оператора генерации потомков
					3.2. Генетические операторы / Оператор репродукции (селекция) (ОР)
			----------------------------------------------------------------------------------------	*/
/*		e2. Мутирование
			*	см. 3.2. Генетические операторы / Операторы скрещивания (кроссинговера) / Оператор мутации 
			----------------------------------------------------------------------------------------	*/
/*		e3. Вычислить значение целевой функции для всех особей	
*/
/*		e4. Формирование нового поколения (селекция) 
			*	см. 3.2. Генетические операторы / Операторы скрещивания (кроссинговера)
			----------------------------------------------------------------------------------------	*/
/*		ЕСЛИ выполняются условия остановки:
			Конец цикла
		ИНАЧЕ 
			Переход к началу цикла.	*/
#include <iostream>
#include <ctime>
#include <vector>
#include <algorithm>
using namespace std;

// определиться с параметрами начальной популяции:
int const	orgs	= 8,	// количество особей
			genes	= 9;	// размер генома (количество генов)

// 1. Задать целевую функцию (приспособленности) для особей популяции
int Fitness(const int *org)
{
	int fitness = 0;
	for (int i = 0; i < genes; i++)
	{
		//cout << "elem: " << org[i] << endl;
		fitness += org[i];
	}
	return fitness;
}
// проверки наличия текущей особи среди скрестившихся
/*  TODO: модифицировать функцию так, чтобы передавать ссылку на вектор 
	и при этом защитить его от изменения через функцию.	*/
int checkCrossOvering(int unsigned cntOrg, vector<int> &crossovered)
{
	/*	бесконечный цикл; выход будет принудительным, 
		когда не останется неспаренных особей */
	while (true)
	{
		// получим случайную особь (по индексу в массиве):
		int orgIndexParent = rand() % cntOrg;
		// http://www.cplusplus.com/reference/algorithm/count/
		/*	если данной особи нет среди скрестившихся	*/
		if (!count(crossovered.begin(), crossovered.end(), orgIndexParent))
		{
			// добавить скрещиваемую особь в массив исключений:
			crossovered.push_back(orgIndexParent);
			// выйти из функции:
			return orgIndexParent;
		}
	}
}
//
void doCrossOver(int parent1, int parent2)
{
	cout << "Скрещиваем особей " << parent1 << " и " << parent2 <<endl;
}
// создать популяцию
/*	решение передачи двухмерного статического массива в функцию по ссылке:
	http://itedu.ru/faq/kak-peredat-v-funkciyu-staticheskiy-dvumernyy-massiv-v-c
	(там же - для динамического)	*/
void generatePopulation(int *Population)
{	
	for (int i = 0; i < orgs; i++)
		for (int j = 0; j < genes; j++)
			*(Population + i*genes + j) = rand() % 2;
}
//
void main2()
{
	// установить локализацию для русского языка:
	setlocale(LC_ALL, "Russian");
	
	// создать точку отсчёта для псевдослучайного числа, привязав к текущему времени:
	srand((unsigned int)time(NULL)); // http://stackoverflow.com/questions/7635580/why-do-i-get-a-warning-about-possible-loss-of-data-when-seeding-the-random-numbe	

	// -----------------------------------------------------------
	// 2. Создать начальную популяцию
	// контейнер (место обитания :)
	int Population[orgs][genes];
	
	// создать популяцию:
	generatePopulation(&Population[0][0]);

	// вывести геном и значение приспособленности особи:
	for (size_t i = 0; i < orgs; i++)
	{
		cout << "Особь " << i+1 << ", genome: [";
		for (size_t j = 0; j < genes; j++)
		{
			if (j) cout << ", ";
			cout << Population[i][j];
		}
		cout << "]; fitness = " << Fitness(Population[i]) << endl;
	}

	// -----------------------------------------------------------
	// e1. Размножение (скрещивание)
	// создать конейнер для скрестившихся особей:
	vector <int> crossovered;
	/*  получить особей для скрещивания, предварительно проверив -
		не были ли они уже скрещены */
	for (int i = 0; i < orgs/2; i++)
	{
		// получить первого родителя:
		int parent1 = checkCrossOvering(orgs, crossovered);
		// получить второго родителя:
		int parent2 = checkCrossOvering(orgs, crossovered);
		// скрестить особей (1 поколение):
		doCrossOver(parent1, parent2);
	}
}